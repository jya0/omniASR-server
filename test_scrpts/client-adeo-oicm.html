<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>omniASR Streaming Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
            line-height: 1.5;
        }

        h1 {
            color: #333;
        }

        #status {
            font-weight: bold;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }

        .status-disconnected {
            background: #fee;
            color: #c33;
        }

        .status-connected {
            background: #eef;
            color: #33c;
        }

        .status-recording {
            background: #efe;
            color: #3c3;
        }

        #transcript {
            white-space: pre-wrap;
            margin-top: 1rem;
            border: 1px solid #ccc;
            padding: 1rem;
            min-height: 200px;
            border-radius: 4px;
            background: #f9f9f9;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .confirmed {
            color: #000;
        }

        .pending {
            color: #888;
            font-style: italic;
        }

        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            cursor: pointer;
            margin-right: 0.5rem;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #ssl-fix-container {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #cce5ff;
            background-color: #e6f2ff;
            /* Light blue info background */
            border-radius: 4px;
        }

        #ssl-fix-container p {
            margin: 0 0 10px 0;
            color: #004085;
        }

        #btnFixSSL {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <h1>omniASR Streaming Client</h1>
    <div id="status" class="status-disconnected">Status: Disconnected</div>

    <div style="margin-bottom: 1rem;">
        <label for="apiKey">API Key:</label>
        <input type="text" id="apiKey" value="sk-xXh95-J0QJwS-ZOLh3j8WGIxIbBxva6YiYIhJebJm_g"
            style="width: 300px; padding: 0.25rem;">
    </div>

    <div>
        <button id="btnConnect">Connect</button>
        <button id="btnStart" disabled>Start Microphone</button>
        <button id="btnStop" disabled>Stop</button>
    </div>

    <div id="ssl-fix-container">
        <p><strong>Connection Failed?</strong> It might be an SSL certificate issue.</p>
        <p>Click below to open the server URL in a new window. You will need to accept the certificate (e.g., click
            "Advanced" -> "Proceed") and then come back here and try connecting again.</p>
        <button id="btnFixSSL">Fix SSL / Accept Certificate</button>
    </div>

    <div id="transcript"></div>

    <script>
        const SAMPLE_RATE = 16000;
        let ws = null;
        let audioContext = null;
        let processor = null;
        let inputStream = null;

        const btnConnect = document.getElementById('btnConnect');
        const btnStart = document.getElementById('btnStart');
        const btnStop = document.getElementById('btnStop');
        const statusDiv = document.getElementById('status');
        const transcriptDiv = document.getElementById('transcript');
        const sslFixContainer = document.getElementById('ssl-fix-container');
        const btnFixSSL = document.getElementById('btnFixSSL');
        const apiKeyInput = document.getElementById('apiKey');

        // The WSS URL
        const WSS_BASE_URL = "wss://inference.adeoaiengine.ecouncil.ae/models/5b1c1b58-f0e1-4ed1-aeb1-85ce3be73a14/ws/v1/audio/transcriptions";

        let finalTranscript = "";

        function setStatus(text, type) {
            statusDiv.textContent = `Status: ${text}`;
            statusDiv.className = `status-${type}`;
        }

        function appendTranscript(text, confirmed, pending, isFinal) {
            if (isFinal) {
                finalTranscript += text + "\n";
                transcriptDiv.innerHTML = `<span class="confirmed">${finalTranscript}</span>`;
            } else {
                // Display history + confirmed part of current + pending part of current
                // If confirmed/pending are not sent by old servers, fallback to 'text' as pending
                let currentConfirmed = confirmed || "";
                let currentPending = pending || (confirmed ? "" : text);

                transcriptDiv.innerHTML = `<span class="confirmed">${finalTranscript}${currentConfirmed}</span><span class="pending">${currentPending}</span>`;
            }
            // Auto scroll
            transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
        }

        btnFixSSL.onclick = () => {
            const httpsUrl = WSS_BASE_URL.replace("wss://", "https://");
            window.open(httpsUrl, '_blank', 'width=800,height=600');
        };

        btnConnect.onclick = async () => {
            // Hide the fix container when retrying
            sslFixContainer.style.display = 'none';

            const apiKey = apiKeyInput.value.trim();
            const wssUrl = `${WSS_BASE_URL}?authorization=${apiKey}`;

            ws = new WebSocket(wssUrl);

            ws.onopen = () => {
                setStatus("Connected", "connected");
                btnConnect.disabled = true;
                btnStart.disabled = false;
                // Ideally hide it if connected, though we already hid it above
                sslFixContainer.style.display = 'none';
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === "ready") {
                    console.log("Server ready:", data);
                } else if (data.text !== undefined) {
                    appendTranscript(data.text, data.confirmed_text, data.pending_text, data.is_final);
                } else if (data.type === "error") {
                    console.error("Server error:", data);
                    alert("Server Error: " + data.message);
                }
            };

            ws.onclose = (event) => {
                setStatus("Disconnected", "disconnected");
                btnConnect.disabled = false;
                btnStart.disabled = true;
                btnStop.disabled = true;
                stopRecording();

                // Heuristic: If close happened very quickly or with error, show the SSL fix option
                // We can't always distinguish SSL error from others in JS, so we suggest it.
                if (!event.wasClean) {
                    sslFixContainer.style.display = 'block';
                }
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                setStatus("Error (Check Console)", "disconnected");
                // Show the help container on error
                sslFixContainer.style.display = 'block';
            };
        };

        btnStart.onclick = async () => {
            try {
                // Initialize Audio Context
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });

                // Get Microphone Stream
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                inputStream = stream;

                // Create Source
                const source = audioContext.createMediaStreamSource(stream);

                // Create Processor (ScriptProcessorNode is deprecated but widely supported for simple tasks)
                // Buffer size 4096 gives ~250ms latency at 16k, but we want 100ms. 
                // 16000 * 0.1 = 1600. Closest power of 2 is 2048 (128ms).
                processor = audioContext.createScriptProcessor(2048, 1, 1);

                source.connect(processor);
                processor.connect(audioContext.destination); // Start processing

                processor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);

                    // Convert Float32 to Int16
                    const buffer = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        // Clamp and scale
                        let s = Math.max(-1, Math.min(1, inputData[i]));
                        buffer[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }

                    // Send to WS if open
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(buffer.buffer);
                    }
                };

                // Send config to server
                ws.send(JSON.stringify({
                    type: "config",
                    sample_rate: SAMPLE_RATE
                }));

                setStatus("Recording...", "recording");
                btnStart.disabled = true;
                btnStop.disabled = false;

            } catch (err) {
                console.error("Mic error:", err);
                alert("Could not access microphone: " + err.message);
            }
        };

        function stopRecording() {
            if (inputStream) {
                inputStream.getTracks().forEach(track => track.stop());
                inputStream = null;
            }
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (ws && ws.readyState === WebSocket.OPEN && btnStop.disabled === false) {
                ws.send(JSON.stringify({ type: "end" }));
                // Force close to ensure fresh session on next connect
                ws.close();
            }

            btnStart.disabled = ws && ws.readyState === WebSocket.OPEN ? false : true;
            btnStop.disabled = true;
            if (ws && ws.readyState === WebSocket.OPEN) setStatus("Connected", "connected");
        }

        btnStop.onclick = stopRecording;
    </script>
</body>

</html>